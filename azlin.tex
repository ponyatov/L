\chapter{azLinux}

Чтобы разобраться как можно собрать встраивамый \linux, в этом разделе описан
набор \make-файлов и файлов конфигурации для сборки минимального \emlinux.
Это обрезанный форк проекта \href{https://github.com/ponyatov/cross}{Cross
Linux}, подробнее описанного в разделе \ref{cross}. Ограничено количество
поддерживаемого железа, упрощены конфигурационные файлы, минимизировано
количество библиотек и программных пакетов.

\bigskip

Изначально идея создания этой системы появилась из желания заменить тухлую
связку x86/DOS/Tur\-bo\-Pas\-cal на что-то

\begin{itemize}
  \item \emph{более переносимое}: на
 энергоэффективное ARM/MIPS-железо, в т.ч. (типа)отечественного производства,
\item \emph{стабильное}: с полноценной многозадачностью,
защитой памяти и данных, и
\item \emph{позволяющее использовать максимум возможностей аппаратуры}: большая
\ram, ECC, gcc-оп\-ти\-ми\-зи\-ро\-ван\-ный 32/64-битный код, USB, CAN, Ethernet,
WiFi, разнообразные носители данных, аппаратный watchdog.
 
\item Также большой интерес представляют \emph{десятки готовые библиотек} сжатия
и кодирования данных, численных методов, ЦОС, и обработки изображений, а также

\item множество \emph{готовых программ, доступных в исходных кодах}\note{для
использования как есть, изучения принципов работы и модификации под
собственные нужды}\ для выполнения различных полезных функций: сетевые серверы,
символьная математика, обработка данных,\ldots

\item Еще одна ключевая фича\ --- \emph{способность}\ \linux\ полностью
\emph{загружаться в \ram\ с \textbf{любых} носителей, в т.ч. заблокированных на
запись}. Это важно для случаев, когда возможны внезапные выключения питания:
вся система работает в \ram-диске, а корректность записи данных на изменяемые
носители можно гибко контролировать программно. При запуске после аварийного
выключения никаких проверок файловых систем не требуется, ОС стартует сразу, а
проверку/починку разделов данных возможно выполнять в фоновом режиме.

\item \emph{Время запуска системы}\ --- на x86 удалось экспериментально получить
время запуска \emph{0.2\,сек от загрузки ядра до начала выполнения
пользователького кода}.
Используя модульное ядро, возможно выполнить критический к времени запуска
пользовательский код до инициализации USB, сети, внешних носителей данных и
тяжелых сервисов.

\end{itemize}

\paragraph{Почему не BuildRoot}

Эта система сборки создавалась как \emph{максимально облегченный пакет
для решения узких задач}, и для освоения технологии кросс-компиляции.
Предполагается что функциональное наполнение не будет развиваться шире набора:

\begin{itemize}
  \item ядро (реального времени)
  \item libc
  \item урезанная командная оболочка (busybox)
  \item несколько прикладных библиотек поддержки (сжатие, кодирование, базовая
  графика)
  \item пользовательский узкоспециализированный код на Си/\cpp
\end{itemize}

Расширять функционал, добавляя libQt, X Window, Apache, MySQL,\ldots, Gnome/KDE
и т.д. не планируется в принципе\ --- \emph{это система для решения узких
прикладных задач}\ на аппаратуре с минимальными ресурсами\note{особенно
интересны процессорные модули в DIMM форм-факторе, только CPU, RAM,
NAND и GPIO гребенка}. \emph{Интерактивная работа}\ с пользователем также
\emph{не предполагается}, доступна только командная консоль\note{ее можно
считать сервисным режимом}, и очень ограниченные графические и мультимедийные
возможности. Если ваши хотелки выходят за этот функционал, рекомендую сразу
уходить на использование ширко известной системы кросс-сборки \linux-систем под
названием \file{BuildRoot}\ref{buildroot}.

\section{Использование пакета сборки az\linux}

\section{APP: Приложение}

\term{Приложение}\ --- короткое кодовое название вашего варианта сборки системы
в целом.

Приложение задается в файле \file{mk/head.mk}\ через
переменную \file{APP}, доступные значения:

\begin{enumerate}
  \item \prog{micro}: минимальная версия системы, только командная консоль
  \item \prog{clock}: простые \linux-powered электронные часы
\end{enumerate}

В \file{app/\$\{APP\}.mk}\ в переменных задаются:

\begin{itemize}
  \item \file{LIBS}: набор используемых библиотек
  \item \file{PACKS}: набор используемых программных пакетов \ref{azpacks}
\end{itemize} 

\section{HW: Поддерживаемое железо}

Конфигурация целевого железа задается в файле \file{mk/head.mk}\ через
переменную \file{HW}, доступные значения приведены в таблице:

\noindent
\begin{tabular}{|l| l l|l l l l l|l|}
\hline
HW & CPU & ARCH & RAM & HDD/NAND & SD & USB & WiFi & GPIO \\
\hline
qemu386 & i486sx & i386 & 32M+ & \uncheckbox\ IDE/SATA & & \uncheckbox &&\\
eeepc701 & CeleronM & i386 & 512M+ & \uncheckbox\ SSD 4G & \uncheckbox\
SD & \checkbox & \uncheckbox\ Atheros AR2425 &\\
\hline
qemuARM & & arm & 32M+ &&&&&\\
cubie1 & AllWinnerA10 & armhf & 1G && \uncheckbox\ $\mu$SD & \checkbox &&\\
rpi & BCM2835 & armel & 512M && \uncheckbox\ SD&\checkbox&&\\
\hline
qemuMIPS & &mips& 32M+ & & & & &\\
mr3020 & AR7240 &mips& 32M & 4M & & \checkbox & \uncheckbox\ Atheros AR9331 &\\
vocore & RT5350 &mips& 32M & 8M & & \uncheckbox
& \uncheckbox\ SoC &\\
bswift & AR9331 &mips& 64M & 16M
NOR & & \uncheckbox\ host & & 20+ \\
\hline
\end{tabular}

\lst{mk/head.mk}{}{azlin/mk/head.mk}

\subsection{i386}

Персоналки с архитектурой \file{i386}\ --- самое сложное семейство с точки
зрения поддержки. Комбинации процессоров, материнских плат и плат расширений
дают сотни вариантов конфигураций, в т.ч. десятки моделей компьютеров в формате
PC/104 и промышленных панелей. Особенно доставляет тот факт, что 95\% периферии
имеет закрытые бинарные драйвера только для \win, поэтому будьте аккуратны с
выбором железа.

\subsubsection{qemu386: эмулятор QEMU}

\lst{hw/qemu386.mk}{}{azlin/hw/qemu386.mk}

\subsubsection{eeepc701: ASUS Eee PC 701}

\lst{hw/eeepc701.mk}{}{azlin/hw/eeepc701.mk}

\subsection{ARM}

\subsubsection{qemuARM: эмулятор QEMU}
\lst{hw/qemuARM.mk}{}{azlin/hw/qemuARM.mk}
\subsubsection{cubie1: Cubie Board v.1}
\subsubsection{rpi: Raspberry Pi model B}
\subsection{MIPS}
\subsubsection{qemuMIPS: эмулятор QEMU}
\lst{hw/qemuMIPS.mk}{}{azlin/hw/qemuMIPS.mk}
\subsubsection{mr3020: роутер MR3020}
\href{http://wiki.openwrt.org/ru/toh/tp-link/tl-mr3020}{mr3020}
\subsubsection{vocore: VoCore} 
\href{http://vocore.io/}{vocore}
\subsubsection{bswift: BlackSwift}
\href{http://habrahabr.ru/post/242731/}{bswift} 

\section{CPU: Конфигурации процессоров}

Настройки на процессор задаются в файле \file{cpu/\$\{CPU\}.mk}.

\subsection{i386}

\lst{cpu/i486sx.mk}{}{azlin/cpu/i486sx.mk}

\lst{cpu/CeleronM.mk}{}{azlin/cpu/CeleronM.mk}

\subsection{ARM}
\subsection{MIPS}

\lst{cpu/AR7240.mk}{}{azlin/cpu/AR7240.mk}

\lst{cpu/RT5350.mk}{}{azlin/cpu/RT5350.mk}

% За счет использования уже существующей и очень большой базы исходных текстов
% ядра, библиотек и программ для \linux, бесплатно доступных в т.ч. и для
% коммерческих приложений, можно на порядки сократить стоимость разработки
% собственных программных компонентов, и при этом получить готовую команду
% бесплатных стронних разработчиков, уже знакомых с созданием ПО для \linux.
% 
% Из недостатков можно отметить:
% \begin{itemize}
%   \item Отсутствие полноценной поддержки режима жесткого реального времени;
%   \item Тяжелое ядро;
%   \begin{itemize}
%   \item Поддерживаются только мощные семейства процессоров;
%   \item Значительные требования по объему \ram\ и общей производительности;
%   \end{itemize}
%   \item Дремучесть техспециалистов, контуженных ТурбоПаскалем и
% Win\-dows\-ом;
% \end{itemize}
% 
% Для \emph{сборки}\ \emlinux-системы используется метод кросс-компиляции, когда
% используется \emph{кросс-тулчейн}, компилирующий весь комплект ПО для компьютера
% с другой архитектурой\footnote{\ типичный пример\ --- сборка ПО на ПК c
% процессором Intel i7 для Raspberry Pi или планшета на процессоре
% AllWinner/Tegra/\ldots}.
% 
% \emlinux\ очень широко применяется на рынке мобильных устройств\footnote{\ в
% т.ч. является основой Android}, и ус\-тройств интенсивно использующих сетевые
% протоколы (роутеры, медиацентры).
% 
% В качествe примера применения возьмем относительно простое приложение:
% многофункциональные настенные часы с синхронизацией времени через \internet, с
% будильником, медиапроигрывателем, блэкджеком и плюшками.
% 
% \section{Требования к системе сборки (\file{BUILD})}
% 
% Требования жесткие\ --- 2х-ядерный процессор, 2+\,Гб \ram, для 4+\, Гб \ram\
% нужен 64х-битный дистрибутив \linux\ (рекомедую Debian), и естественно никаких
% виртуалок.
% 
% Возможна установка системы на флешку, в этом случае требования к \ram\ еще более
% ужесточаются\ --- потребуется каталоги с временными файлами смонтировать как
% \file{tmpfs}:
% 
% \lstinputlisting[title=добавить в \file{/etc/fstab}]{fstab.txt}
% 
% Можно попытаться сделать \file{билд-сервер}\ и на худшем железе, но будьте
% готовы к тормозам или внезапному окончанию памяти\ --- ресурсоемка сборка
% тяжелых библиотек типа \file{libQt}\ или крупных пакетов типа \file{gcc}.
% 
% Вы можете
% попробовать поставить \linux\ на виртуалку, на флешку, и на жесткий диск (если
% найдете место) и оценить возможности этих вариантов на сборке пакета \file{gcc}.
% При сборке с флешки на ноутбуке в 2\,Гб \ram\ мне для сборки \file{gcc}\
% пришлось временно размонтировать \file{cross/src}, сделать \file{./mk.rc \&\&
% make gcc ramclean}, а потом примонтировать \file{tmpfs}\ опять на \file{src}.
% 
% Сборка под MinGW/Cygwin совершенно неживая. Если совсем никак без винды\ ---
% используйте виртуалки, и будьте готовы ждать.

\section{Пакеты}\label{azpacks}

