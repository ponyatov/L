\secrel{azLinux}\label{azlin}\secdown

Чтобы разобраться как можно собрать встраивамый \linux, в этом разделе описан
набор \make-файлов и файлов конфигурации для сборки минимального em\linux.
Это обрезанный форк проекта \href{https://github.com/user/cross}{Cross
Linux}, подробнее описанного в разделе \ref{cross}. Ограничено количество
поддерживаемого железа, упрощены конфигурационные файлы, минимизировано
количество библиотек и программных пакетов.

\bigskip

Изначально идея создания этой системы появилась из желания заменить тухлую
связку x86/DOS/Tur\-bo\-Pas\-cal на что-то

\begin{itemize}
  \item \emph{более переносимое}: на
 энергоэффективное ARM/MIPS-железо, в т.ч. (типа)отечественного производства,
\item \emph{стабильное}: с полноценной многозадачностью,
защитой памяти и данных, и
\item \emph{позволяющее использовать максимум возможностей аппаратуры}: большая
\ram, ECC, gcc-оп\-ти\-ми\-зи\-ро\-ван\-ный 32/64-битный код, USB, CAN, Ethernet,
WiFi, разнообразные носители данных, аппаратный watchdog.

\item Также большой интерес представляют \emph{десятки готовые библиотек} сжатия
и кодирования данных, численных методов, ЦОС, и обработки изображений, а также

\item множество \emph{готовых программ, доступных в исходных кодах}\note{для
использования как есть, изучения принципов работы и модификации под
собственные нужды}\ для выполнения различных полезных функций: сетевые серверы,
символьная математика, обработка данных,\ldots

\item Еще одна ключевая фича\ --- \emph{способность}\ \linux\ полностью
\emph{загружаться в \ram\ с \textbf{любых} носителей, в т.ч. заблокированных на
запись}. Это важно для случаев, когда возможны внезапные выключения питания:
вся система работает в \ram-диске, а корректность записи данных на изменяемые
носители можно гибко контролировать программно. При запуске после аварийного
выключения никаких проверок файловых систем не требуется, ОС стартует сразу, а
проверку/починку разделов данных возможно выполнять в фоновом режиме.

\item \emph{Время запуска системы}\ --- на x86 удалось экспериментально получить
время запуска \emph{0.2\,сек от загрузки ядра до начала выполнения
пользователького кода}.
Используя модульное ядро, возможно выполнить критический к времени запуска
пользовательский код до инициализации USB, сети, внешних носителей данных и
тяжелых сервисов.

\end{itemize}

\paragraph{Почему не BuildRoot}

Эта система сборки создавалась как \emph{максимально облегченный пакет
для решения узких задач}, и для освоения технологии кросс-компиляции.
Предполагается что функциональное наполнение не будет развиваться шире набора:

\begin{itemize}[nosep]
  \item ядро (реального времени)
  \item $\mu$libc
  \item урезанная командная оболочка (busybox)
  \item несколько прикладных библиотек поддержки (сжатие, кодирование, базовая
  графика)
  \item пользовательский узкоспециализированный код на Си/\cpp
\end{itemize}

Расширять функционал, добавляя libQt, X Window, Apache, MySQL,\ldots, Gnome/KDE
и т.д. не планируется в принципе\ --- \emph{это система для решения узких
прикладных задач}\ на аппаратуре с минимальными ресурсами\note{особенно
интересны процессорные модули в DIMM форм-факторе, только CPU, RAM,
NAND и GPIO гребенка}. \emph{Интерактивная работа}\ с пользователем также
\emph{не предполагается}, доступна только командная консоль\note{ее можно
считать сервисным режимом}, и очень ограниченные графические и мультимедийные
возможности. Если ваши хотелки выходят за этот функционал, рекомендую сразу
уходить на использование ширко известной системы кросс-сборки \linux-систем под
названием \file{BuildRoot}\ref{buildroot}.

\secrel{Требования к системе сборки (\file{BUILD}-хост)}

2х-ядерный процессор, 2+\,Гб \ram, для 4+\, Гб \ram\ нужен 64х-битный
дистрибутив \linux\ (рекомедую Debian), и естественно никаких виртуалок.
Возможна установка системы на флешку, в этом случае требования к \ram\ еще более
ужесточаются\ --- потребуется каталоги с временными файлами смонтировать как
\file{tmpfs}:

\lst{добавить в \file{/etc/fstab}}{}{azlin/doc/fstab.txt}

Можно попытаться сделать \term{билд-сервер}\ и на худшем железе, но будьте
готовы к тормозам или внезапному окончанию памяти\ --- ресурсоемка сборка
тяжелых библиотек типа \pack{libQt}\ или крупных пакетов типа \pack{gcc}.

Вы можете попробовать поставить \linux\ на виртуалку, на флешку, и на жесткий
диск (если найдете место) и оценить возможности этих вариантов на сборке пакета
\pack{gcc0}. При сборке с флешки на ноутбуке с 2\,Гб \ram\ мне для сборки
\pack{gcc0}\ пришлось временно размонтировать \file{cross/src}, сделать
\file{make gcc ramclean}, а потом примонтировать \file{tmpfs}\
опять на \file{src}.

Сборка под MinGW/Cygwin совершенно неживая. Если совсем никак без винды\ ---
используйте виртуалки, и будьте готовы ждать.

\secrel{Понятие \term{пакет}}

Прежде чем продолжить, введем понятие \termdef{пакет}{пакет}. В az\linux\
\term{пакетом}\ называется одна или несколько частей скриптов сборки,
обозначаемых именем. В чем-то это похоже на бинарные пакеты обычных
дистрибутивов \linux\ --- чтобы добавить в систему какой-то функционал, мы
устанавливаем \term{бинарный пакет}.
Но есть и отличие: пакет дистрибутива это реальный архивный файл, содержащий в
себе файлы программ, данных; в az\linux\ пакет\ --- виртуальная штука с именем.

Просматривая файлы в каталоге \file{mk/}, легко найти имена пакетов по шаблону:

\begin{verbatim}
.PHONY: somename
somename: [зависимые файлы]
    [команда1]
    ...
\end{verbatim}

Если вы запустите команду:

\begin{verbatim}
cd ~/az ; make somename
\end{verbatim}

запустится \termdef{сборка пакета}{сборка пакета}\ \pack{somename}.

Но не нужно забывать, что кроме этой секции в \file{.mk}, существуют зависимости
между файлами, при работе команд сборки динамически создаются и изменяются
файлы, иногда что-то скачивается из \internet а\ --- все эти процессы тоже
входят в пакет.

\bigskip
Часть пакетов не связана со сборкой программ, а выполняют служебные функции,
поэтому для них правильнее будет фраза \term{запуск пакета}.

\bigskip
Все действия выполняются с помощью команды \pack{make}. Обратите особое внимание
на то, что \file{Makefile}\ подгружает части из каталога \file{mk/}, поэтому
\emph{если вы добавляете новый скрипт, не забудьте прописать его в
\file{Makefile}}.

\lstx{Makefile}{}{../azlin/Makefile}{mk}\index{azLinux!скрипт!Makefile}

\secrel{Клонирование проекта \pack{az\linux}} \label{azclone}

При необходимости вносить правки\note{что естественно\ --- вам потребуется
добавлять свои пакеты и поддержку железа}\ работайте с вашим
собственным форком на GitHub.

\nopagebreak\bigskip
az\linux\ разрабатывается по нескольким веткам:

\begin{tabular}{l l}
master & основная универсальная ветка, включает все скрипты сборки и пакеты \\
& в книгу включается именно эта ветка, набор скриптов в других ветках будет
отличаться \\
minimal & минимальная система для нескольких платформ \\
clock & \linux-powered электронные часы/контроллер умного дома \\
math & математический софт и библиотеки для вычислительных кластеров beowulf \\
desk & десктопная сборка с функционалом $\sim$\win 95 \\
cnc & система управления для станков с ЧПУ \\
\end{tabular}
\bigskip

Сделайте свой форк с репозитория \url{https://github.com/ponyatov/azlin}.
\bigskip

Получите клон системы сборки из репозитория выбрав нужную ветку:


\begin{verbatim}
cd ~
git clone --depth=1 -o gh -b minimal git@github.com:user/azlin.git myazlin
\end{verbatim}

При необходимости обновитесь:

\begin{verbatim}
cd ~/az ; git pull
\end{verbatim}

\secrel{Общий порядок сборки}

Каждый пакет собирается командой:

\begin{verbatim}
make [HW=rpi] [APP=clock] [CCACHE=] [RAMCLEAN=echo] <package>
\end{verbatim}

\bigskip
\begin{itemize}[nosep]
  \item \var{HW} выбор аппаратной платформы \file{hw/}
  \item \var{APP} выбор приложения \file{app/}
  \item \var{CCACHE=} пустая переменная блокирует использование \prog{ccache} 
  \item \var{RAMCLEAN} переменная задает команду, которой передается набор
  каталогов, которые нужно зачистить; по умолчанию это \file{rm -rf}, заданием
  \file{echo}\ зачистка отключается (нужно если вы собираете систему в
  каталогах \file{src/}, \file{tmp/}\ не в \ram, а на диске)
\end{itemize}

\bigskip
\begin{enumerate}[nosep]
  \item \pack{dirs} создание дерева каталогов \ref{azdirs}
  \item \pack{gz} закачка архивов исходников \ref{azgz}
  \item \pack{cross0} сборка кросс-компилятора \ref{azcross0}
  \begin{enumerate}
    \item \pack{binutils0} ассемблер, линкер и утилиты \ref{azbinutils0}
    \item \pack{cclibs0} библиотеки для сборки \pack{gcc} \ref{azcclibs0}
    \item \pack{gcc0} сборка минимального кросс-компилятора Си \ref{azgcc0}
  \end{enumerate}
  \item \pack{core} сборка основной системы \ref{azcore}
  \\ \pack{coref} сборка основной системы + GNU Fortran \ref{azcoref}
  \begin{enumerate}
    \item \pack{kernel} ядро \linux\ \ref{azkernel}
    \item \pack{ulibc} библиотека \pack{uClibc} \ref{azulibc}
    \item \pack{busybox} набор утилит \pack{busybox} \ref{azbb}
    \item \pack{gcc} пересборка полного кросс-компилятора Си/\cpp \ref{azgcc}
    \\ \pack{gccf} кросс-компилятор Си/\cpp/Fortran \ref{azgccf}
  \end{enumerate}
  \item \pack{libs} сборка библиотек \file{\$\{LIBS\}} \ref{azlibs}
  \item \pack{apps} сборка прикладных пакетов \file{\$\{APPS\}} \ref{azapps}
  \item \pack{user} сборка пользовательского кода \ref{azuser}
  \item \pack{root} формирование корневой файловой системы \ref{azroot}
  \item \pack{boot} сборка загрузчика \ref{azboot}
   \pack{syslinux}/\pack{grub}/\pack{uboot}
  \item \pack{emu} запуск собранной системы в эмуляторе \ref{azemu}
  \item \pack{netboot} сетевая загрузка \ref{aznetboot}
  \item \pack{firmware} прошивка на устройство \ref{azfirmware}
\end{enumerate}

\secrel{Фиксация переменных}

Если вам требуется собрать систему со значениями переменных, отличающихся от
тех, которые прописаны в make-файлах, при запуске \emph{всех}\ пакетов нужно
указывать трюбуемые значения в командной строке. Это позволить легко выбрать
нужный вам вариант сборки.

\begin{verbatim}
make HW=rpi APP=clock distclean dirs tc core libs apps boot root
\end{verbatim}

При таком указании все переназначения для этих переменных игнорируются, поэтому
возможны некоторые сложности с указанием например опций оптимизации.

\secrel{\pack{dirs}: Создание дерева каталогов} \label{azdirs}

После загрузки или обновления запустите пакет \pack{dirs}:

\begin{verbatim}
make dirs
mkdir -p /home/user/Azbuka/azlin/gz /home/user/Azbuka/azlin/src
/home/user/Azbuka/azlin/tmp /home/user/Azbuka/azlin/x86_64-linux-gnu
/home/user/Azbuka/azlin/qemu386-clock /home/user/Azbuka/azlin/qemu386-clock/boot
\end{verbatim}
\begin{verbatim}
ls -la
итого 71
-rw-r--r-- 1 user user  2087 Дек  8 13:26 Makefile
drwxr-xr-x 2 user user  4096 Дек  8 11:43 mk
drwxr-xr-x 2 user user  4096 Дек  8 11:43 app
drwxr-xr-x 2 user user  4096 Дек  8 11:43 hw
drwxr-xr-x 2 user user  4096 Дек  8 11:43 cpu
drwxr-xr-x 2 user user  4096 Дек  8 11:43 arch
drwxr-xr-x 2 user user  4096 Дек  8 11:43 app
drwxr-xr-x 2 user user  4096 Дек  8 13:26 gz
drwxr-xr-x 2 user user  4096 Дек  8 13:26 src
drwxr-xr-x 2 user user  4096 Дек  8 13:26 tmp
drwxr-xr-x 3 user user  4096 Дек  8 13:26 x86micro
drwxr-xr-x 2 user user  4096 Дек  8 13:26 x86micro.cross
-rw-r--r-- 1 user user   147 Дек  8 11:43 README.md
-rw-r--r-- 1 user user 17699 Дек  8 13:25 azlin.tex
\end{verbatim}

Пакет \pack{dirs}\ прописан в файле

\lstx{mk/dirs.mk}{}{azlin/mk/dirs.mk}{mk}\index{azLinux!пакет!dirs}

Встроенная переменная \file{PWD}\ содержит полное имя каталога, из которого был
запущен \pack{make}.

\bigskip
Каталог зеркала архивов исхоных текстов программ

\lstx{GZ}{}{tmp/azlin_GZ}{mk}\index{azLinux!переменная!GZ}

Каталог распаковки исходных текстов: некоторые пакеты должна собираться в дереве
исходников

\lstx{SRC}{}{tmp/azlin_SRC}{mk}\index{azLinux!переменная!SRC}

Каталог out-of-tree сборки: остальные пакеты умеют собираться вне дерева
исходников, если хватает \ram\ этот каталог удобно монировать как \file{tmpfs}

\lstx{TMP}{}{tmp/azlin_TMP}{mk}\index{azLinux!переменная!TMP}

Переменная \file{BUILD}\ задает \term{триплет}\ системы, на которой вы
собираете: x86\_64-linux-gnu, i686-linux-gnu или что-то подобное. Для получения
триплета используется подстановка строки, выдаваемой запуском \pack{gcc}.

\lstx{BUILD}{}{tmp/azlin_BUILD}{mk}\index{azLinux!переменная!BUILD}

Каталог в который собирается кросс-компилятор. Используется триплет
рабочей \linux-системы.

\lstx{TC}{}{tmp/azlin_TC}{mk}\index{azLinux!переменная!TC}

Каталог целевой \file{rootfs}. Отдельно прописан загрузочный каталог, в который
будет записываться собранное ядро, образ \term{initrd}, бинарники и конфиги
загрузчика. Имя \file{ROOT}\ создается из двух переменных, описанных далее: имя
аппаратной платформы \file{HW}\ref{azhw}\ и имени приложения
\file{APP}\ref{azapp}.

\lstx{ROOT}{}{tmp/azlin_ROOT}{mk}\index{azLinux!переменная!ROOT}
\lstx{BOOT}{}{tmp/azlin_BOOT}{mk}\index{azLinux!переменная!BOOT}

Список всех рабочих каталогов в одной переменной:

\lstx{DIRS}{}{tmp/azlin_DIRS}{mk}\index{azLinux!переменная!DIRS}

\secrel{\pack{gz}: Загрузка архивов исходников} \label{azgz}

\lstx{mk/gz.mk}{}{azlin/mk/gz.mk}{mk}

\secrel{APP: Приложение}\label{azapp}

\term{Приложение}\ --- короткое кодовое название вашего варианта сборки системы
в целом.

Приложение задается в файле \file{mk/head.mk}\ через
переменную \file{APP}, доступные значения:

\begin{enumerate}
  \item \pack{micro}: минимальная версия системы, только командная консоль
  \item \pack{clock}: простые \linux-powered электронные часы
\end{enumerate}

Значение переменной \file{APP}\ по умолчанию задано в \file{mk/head.mk}:

\lstx{APP @ hw/head.mk}{}{tmp/azlin_APP}{mk}
\index{azLinux!настройка!приложение}
\index{azLinux!переменная!APP}

Если вам нужно собрать другое приложение, вы можете переопределить значение из
командной строки при запуске \emph{всех}\ пакетов:

\begin{verbatim}
make APP=micro distclean dirs tc core libs apps
\end{verbatim}

В \file{app/\$\{APP\}.mk}\ в переменных задаются:

\begin{itemize}
  \item \file{LIBS}: набор используемых библиотек
  \item \file{PACKS}: набор используемых программных пакетов \ref{azpacks}
\end{itemize}

\lstx{app/micro.mk}{}{../azlin/app/micro.mk}{mk}\index{azLinux!приложение!micro}

\lstx{app/clock.mk}{}{../azlin/app/clock.mk}{mk}\index{azLinux!приложение!clock}

\secrel{HW: Поддерживаемое железо}\label{azhw}\index{azLinux!железо}

Конфигурация целевого железа задается в файле \file{mk/head.mk}\ через
переменную \file{HW}, доступные значения приведены в таблице:

\noindent
\begin{tabular}{|l| l l|l l l l l l|l|}
\hline
HW & CPU & ARCH & RAM & HD & SD & USB & Eth & WiFi & GPIO \\
\hline
qemu386 \ref{qemu3865} & i486sx & i386 & 32M+ & \uncheckbox\ IDE & & \uncheckbox
& ne2k &&\\
eeepc701 \ref{eeepc701} & CeleronM & i386 & 512M+ & \uncheckbox\ SSD &
\uncheckbox\ SD & \checkbox & A?? & \uncheckbox\ AR2425 &\\
gac1037 \ref{gac1037} & Celeron1037U & x86\_64 & 1G+ & \uncheckbox\ SATA & &
\checkbox & 2$\times$RTL8111 &&\\
\hline
qemuARM & & arm & 32M+ &&&&&&\\
cubie1 \ref{cubie1} & AllWinnerA10 & armhf & 1G && \uncheckbox\ $\mu$SD &
\checkbox &&&\\
rpi \ref{rpi} & BCM2835 & armel & 512M && \uncheckbox\ SD&\checkbox&&&\\
tion \ref{tion} & PXA270 & arm?? &&&&&&&\\
mb77 \ref{mb77} & К1879ХБ1Я & arm?? &&&&&&&\\
\hline
qemuMIPS & &mips& 32M+ & & & & &&\\
mr3020 \ref{mr3020} & AR7240 &mips& 32M & 4M & & \checkbox && \uncheckbox\
AR9331 &\\
vocore \ref{vocore} & RT5350 &mips& 32M & 8M & & \uncheckbox
&& \uncheckbox\ SoC &\\
bswift && AR9331 &mips& 64M & 16M & \uncheckbox\ & & & 20+ \\
\hline
\end{tabular}

\lstx{mk/head.mk}{}{../azlin/mk/head.mk}{mk}

\secrel{i386}\secdown\index{azLinux!железо!i386}

Персоналки с архитектурой \file{i386}\ --- самое сложное семейство с точки
зрения поддержки. Комбинации процессоров, материнских плат и плат расширений
дают сотни вариантов конфигураций, в т.ч. десятки моделей компьютеров в формате
PC/104 и промышленных панелей. Особенно доставляет тот факт, что 95\% периферии
имеет закрытые бинарные драйвера только для \win, поэтому будьте аккуратны с
выбором железа.

\secrel{qemu386: эмулятор QEMU}

\lstx{hw/qemu386.mk}{}{../azlin/hw/qemu386.mk}{mk}\index{azLinux!железо!QEMU}

\clearpage
\secrel{eeepc701: ASUS Eee PC 701}\label{eeepc701}

\bigskip
\begin{tabular}{p{0.45\textwidth} p{0.45\textwidth}}
\includegraphics[width=0.35\textwidth]{azlin/doc/eeepc701.jpg}
&
\begin{tabular}{l l}
CPU & CeleronM \\
\ram & 512 \\
SSD & 4G \\
видео & \checkbox\ Intel HDA, VGA DSUB \\
Ethernet & \checkbox\ 10/100M \\
WiFi & \checkbox\ \\
USB & \checkbox\ USB1.1 host \\
SD & \checkbox \\
\end{tabular}
\\
\end{tabular}

\bigskip

\lstx{hw/eeepc701.mk}{}{../azlin/hw/eeepc701.mk}{mk}\index{azLinux!железо!ASUS Eee PC 701}

\clearpage
\secrel{gac1037: Gigabyte GA-C1037UN-EU rev.2}

\begin{tabular}{p{0.45\textheight} p{0.45\textheight}}
\includegraphics[height=0.45\textheight]{azlin/doc/gac1037.jpg} &
\begin{tabular}{l l}
CPU & Celeron 1037U \\
\ram & 2 $\times$ DDR3, max 16G, 2 канала \\
чипсет & Intel NM70 \\
сеть & 2 $\times$ Realtek® GbE 1Gb (rtl8111) \\
HDD & 2 $\times$ SATA2 (3Gb/s), 1 $\times$ SATA3 (6Gb/s), 1 $\times$ eSATA\\
USB & 6 $\times$ USB3.0 \\
видео & IntelGMA, выходы на VGA D-Sub и HDMI 1.4\\
аудио & Realtek ALC887 (HDA) \\
PCI & $\times$1 \\
&\\
\end{tabular}
\\
\end{tabular}

В качестве варианта 64-битной платформы взята портативная материнка для
неттопов: Gigabyte GA-C1037UN-EU. На ней возможны два варианта сборки:

\begin{enumerate}
  \item \emph{x86\_64/x64}: нативный \verb|CPU=Celeron1037u|
  \item \emph{i686/x32}: режим соместимости со старыми процессорами
  \verb|CPU=i686|
\end{enumerate}

\url{http://www.ixbt.com/news/hard/index.shtml?17/33/31}

\clearpage
На текущий момент эта материнка\ --- оптимальный вариант для офисного, рабочего
неигрового компьютера, или базы для изготовления мобильной рабочей станции в
миникейсе: комплект из GA-C1037UN-EU и блока питания стоит порядка 5 тыс.руб,
при этом возможна установка до 2$\times$8G \ram, что пока недоступно на дешевых
ноутбуках. \emph{Но\ --- \textsc{отвратительный} радиатор на мосте NM70, нагрев
до $70^{o}C$, в обязательном порядке делать сквозную продувку корпуса \textbf{до
включения материнки}.}

\begin{tabular}{l l}
материнская плата& GA-C1037UN-EU rev.2 \\
CPU& Celeron 1037U (впаян) \\
охлаждение& \emph{отвратительное, обязательны кулера на все чипы и сквозная
продувка корпуса},
\\
\ram& 1$\times$8G DDR3 (в планах 2$\times$8G) \\
HDD & \emph{нет}, используется флешка 8G USB3 Transcend JF750 (возможно SATA
SSD) \\
TFT & китайский 3.5'' автомониторчик + конвертер HDMI2RCA на случай\\&
посмотреть видеовывод, обычно везде где я использую эту поделку,\\& есть VGA
монитор или хотя бы большой телевизор\\
электропитание& БП Hipro HPE-350W + автоинвертор\\& батарея не требуется, под
боком всегда есть 220 или 12\,В\\
& по необходимости в транспорт грузится пара заряженных автоаккумуляторов\\
\end{tabular}
\bigskip

\lstx{hw/gac1037.mk}{}{../azlin/hw/gac1037.mk}{mk}\index{azLinux!железо!Gigabyte GA-C1037UN-EU}

\secup

\secrel{ARM}\secdown

\secrel{qemuARM: эмулятор QEMU}
\lstx{hw/qemuARM.mk}{}{../azlin/hw/qemuARM.mk}{mk}\index{azLinux!железо!QEMU}

\secrel{cubie1: Cubie Board v.1}\label{cubie1}

\secrel{rpi: Raspberry Pi model B}\label{rpi}

\clearpage
\secrel{tion: ТионПро270}\label{tion}

ЗАО ``Завод Электрооборудования''

\url{http://www.zao-zeo.ru/catalog/sbc/67-tion-pro270}

\bigskip
\begin{tabular}{p{0.45\textwidth} p{0.45\textwidth}}
\includegraphics[width=0.45\textwidth]{azlin/doc/tion270.jpg}
&
\begin{tabular}{l l}
CPU & Marvell XScale PXA270 @ 416/520 МГц \\
\ram & 64 \\
Flash & 32 \\
видео & \checkbox\ VGA DSUB \\
Ethernet & \checkbox\ 10/100M \\
USB & \checkbox\ USB1.1 host \\
$\mu$SD & \checkbox \\
\end{tabular}
\\
\end{tabular}

\clearpage
\secrel{mb77: Микрокомпьютер МВ77.07 на базе СБИС К1879ХБ1Я}\label{mb77}

ЗАО НТЦ ``Модуль''

\url{http://www.module.ru/catalog/micro/micro_pc/}

\bigskip
\begin{tabular}{p{0.45\textwidth} p{0.45\textwidth}}
\includegraphics[width=0.45\textwidth]{azlin/doc/mb77.png}
&
\begin{tabular}{l l}
CPU &
\href{http://www.module.ru/catalog/micro/mikroshema\_dekodera\_cifrovogo\_televizionnogo\_signala\_sbis\_k1879hb1ya/}{К1879ХБ1Я}
\\&ARM1176JZF-S @ 324 МГц \\
GPU & NeuroMatrix NMC3 @ 324 МГц \\
\ram & \\
Flash & \\
видео & HDMI \\
Ethernet & \checkbox\ 10/100M \\
USB & \checkbox\ USB2 host \\
\end{tabular}
\\
\end{tabular}

\secup

\secrel{MIPS}\secdown
\secrel{qemuMIPS: эмулятор QEMU}
\lstx{hw/qemuMIPS.mk}{}{../azlin/hw/qemuMIPS.mk}{mk}\index{azLinux!железо!QEMU}

\clearpage
\secrel{mr3020: роутер MR3020}

\url{http://wiki.openwrt.org/ru/toh/tp-link/tl-mr3020}

\bigskip
\begin{tabular}{p{0.45\textwidth} p{0.45\textwidth}}
\begin{tabular}{l}
\includegraphics[width=0.35\textwidth]{azlin/doc/mr3020.jpg}\\
\includegraphics[width=0.35\textwidth]{azlin/doc/mr3020pcb.jpg}\\
\end{tabular}
&
\begin{tabular}{l l}
CPU & Atheros AR9330 rev.1 @ 400 MHz \\
\ram & 32 \\
Flash & 4 \\
WiFi & \checkbox\ 802.11 b/g/n 150Mbps \\
Ethernet & \checkbox\ 10/100M \\
USB & \checkbox\ USB2 \\
\end{tabular}
\\
\end{tabular}

\clearpage
\secrel{vocore: VoCore}\label{vocore} \index{azLinux!железо!VoCore}

\href{http://vocore.io/}{vocore}

% \includegraphics[height=0.45\textheight]{azlin/mk/vocore1.jpg}
%
% \includegraphics[height=0.45\textheight]{azlin/mk/vocore2.jpg}

\begin{tabular}{p{0.45\textwidth} p{0.45\textwidth}}
\begin{tabular}{l}
\includegraphics[width=0.45\textwidth]{azlin/doc/vocore1.jpg} \\
\includegraphics[width=0.45\textwidth]{azlin/doc/vocore2.jpg} \\
\end{tabular} &
\begin{tabular}{l l}
CPU & SoC Ralink RT5350F \\&/MIPS 24KEc/ @ 360 MHz \\
\ram & 32M \\
Flash & 16M \\
% чипсет & Intel NM70 \\
WiFi & 802.11n 1T/1R (1x1:1) 2.4 GHz \\&150Mbps MAC/BB/PA/RF \\
Ethernet & \checkbox \\
% HDD & 2 $\timesSATA2 (3Gb/s), 1 $\timesSATA3 (6Gb/s), 1 $\timeseSATA\\
USB & \checkbox \\
% видео & IntelGMA, выходы на VGA D-Sub и HDMI 1.4\\
% аудио & Realtek ALC887 (HDA) \\
% PCI & $\times$1 \\
GPIO & \\
$\mu$SD & \checkbox \\
\end{tabular}
\\
\end{tabular}

\secrel{bswift: BlackSwift} \index{azLinux!железо!BlackSwift}
\href{http://habrahabr.ru/post/242731/}{bswift}
\secup

\secrel{CPU: Конфигурации процессоров}\secdown

Настройки на процессор задаются в файле \file{cpu/\$\{CPU\}.mk}.

\begin{tabular}{p{0.15\textwidth} p{0.8\textwidth}}
\file{ARCH} & архитектура целевой системы, используется при конфигурировании
ядра \\
\file{TARGET} & \term{триплет целевой системы}, параметр задает тип целевой
системы при сборке кросс-компилятора и используется во всех скриптах
\pack{configure}\ при сборке остальных пакетов \\
\file{CFG\_CPU} & параметры при сборке кросс-компилятора \\
\file{CPU\_FLAGS} & параметры \pack{gcc}\ для оптимизации кода \\
\end{tabular}

\secrel{i386}

\lstx{cpu/i486sx.mk}{}{azlin/cpu/i486sx.mk}{mk}
\index{azLinux!железо!i486sx}

\lstx{cpu/CeleronM.mk}{}{azlin/cpu/CeleronM.mk}{mk}
\index{azLinux!железо!CeleronM}

\lstx{cpu/Celeron1037U.mk}{}{azlin/cpu/Celeron1037U.mk}{mk}
\index{azLinux!железо!Celeron1037U}

\secrel{ARM}
\secrel{MIPS}

\lstx{cpu/AR7240.mk}{}{../azlin/cpu/AR7240.mk}{mk}\index{azLinux!железо!AR7240}

\lstx{cpu/RT5350.mk}{}{../azlin/cpu/RT5350.mk}{mk}\index{azLinux!железо!RT5350}

\secup

\secrel{Пакеты}\secdown\label{azpacks}

\secrel{\file{mk/versions.mk}: Версии пакетов}\label{azpackver}

\secrel{\pack{tc}: кросс-компилятор}

\lstx{mk/versions.mk}{}{tmp/azlin_versions.cross}{mk}

\secrel{\pack{core}: ядро}

\lstx{mk/versions.mk}{}{tmp/azlin_versions.core}{mk}

\secrel{\pack{boot}: загрузчики}

\lstx{mk/versions.mk}{}{tmp/azlin_versions.boot}{mk}

\secrel{\pack{libs}: библиотеки}

\lstx{mk/versions.mk}{}{tmp/azlin_versions.libs}{mk}

\secrel{\pack{tc}: сборка кросс-компилятора} \label{aztc}

\lstx{}{}{azlin/mk/cross.mk}{mk}

\secrel{\pack{binutils}: ассемблер, линкер и утилиты} \label{azbinutils}

\begin{tabular}{l l}
--target=\$(TARGET)& триплет целевой платформы\\
\$(CFG\_ARCH)&параметры архитектуры\\
\$(CFG\_CPU)&параметры процессора\\
--program-prefix&префикс \verb|<prefix>-(as|ld|..)|\\
--with-sysroot& каталог в котором находятся хедеры и библиотеки\\
--with-native-system-header-dir=/include&каталог с хедерами\\
--enable-lto&[L]ink[T]ime [O]ptimization\\
\end{tabular}

\clearpage
\lstx{arch/i386.mk}{}{azlin/arch/i386.mk}{mk}

\begin{tabular}{l l}
--disable-multilib&выключить смешанный 32/64-битный режим\\
\end{tabular}

\lstx{arch/arm.mk}{}{azlin/arch/arm.mk}{mk}

\begin{tabular}{l l}
--enable-interwork&разрешить смешанный код ARM/THUMB\\
\end{tabular}

\lstx{cpu/i486sx.mk}{}{azlin/cpu/i486sx.mk}{mk}

\secrel{\pack{cclibs}: библиотеки для сборки \pack{gcc}} \label{azcclibs}

\pack{gmp} \pack{mpfr} \pack{mpc}

\secrel{\pack{gcc0}: сборка минимального кросс-компилятора Си}
\label{azgcc0}

При сборке \pack{gcc0}/\pack{gcc} отключайте \pack{ccache}: кэш при разовых сборках
не работает, но при монтировании как tmpfs потребляет слишком много \ram:

\begin{verbatim}
$ make CCACHE= gcc0
\end{verbatim}

\secrel{\pack{gcc}: пересборка полного кросс-компилятора Си/\cpp}
\label{azgcc}
%
Пакет собирается \emph{после сборки \pack{core}}.

\secrel{\pack{core}: сборка основной системы} \label{azcore}

\lstx{mk/core.mk}{}{azlin/mk/core.mk}{mk}

\secrel{\pack{kernel}: ядро \linux} \label{azkernel}

\lstx{mk/kernel.mk}{}{azlin/mk/kernel.mk}{mk}

\begin{tabular}{l l}
\file{ARCH} & архитектура: \file{src/linux-x.x.x/arch/*} \\
\file{INSTALL\_HDR\_PATH} & путь установки \term{хедеров ядра} \\
\end{tabular}

\begin{enumerate}
  \item подготовка к сборке с пустым \term{конфигом}
  \file{src/linux-x.x.x/.config}
  \item накатываем на пустой \file{.config} файлы-модификаторы, содержащие
  переопределения переменных конфигурации:
  \begin{itemize}
    \item \file{all} универсальные параметры ядра для всех платформ
    \item \file{arch} параметры, специфичные для архитектуры
    \item \file{cpu} параметры, адаптирующие ядро к конкретному процессору
    (эмулятор FPU, возможности управления тактовой частотой и потреблением,
    поддержка многоядерности и т.п.)
    \item \file{hw} параметры чипсета и периферии материнской платы
    (\term{модули ядра} = драйвера)
    \item \file{app} параметры, в основном \emph{отключаемые} для конкретного
    \term{приложения} (отключение графики, режим реального времени,
    спец.параметры)
  \end{itemize}
  \item установка параметров кросс-компиляции и имени сборки
  \item запуск интерактивного меню конфигурирования, выйти с сохранением
  \item сборка ядра
  \item копирование готового файла ядра в \file{\$\{BOOT\}}
  \item генерация \term{хедеров}\ в \file{\$\{ROOT\}}
\end{enumerate}

\bigskip
Все параметры ядра идут с префиксом \file{CONFIG\_}:

\begin{itemize}
  \item \pack{core.mk}
  \begin{itemize}
    \item \file{CROSS\_COMPILE} префикс кросс-компилятора
    \verb#<pfx>-(gcc|as|ld..)#
    \item \file{LOCALVERSION} суффикс ядра \verb|linux-x.x.x-suffix|
    \item \file{DEFAULT\_HOSTNAME} имя компьютера \file{<host>.<domain>}
  \end{itemize}
  \item \pack{all} \emph{для всех платформ}
  \begin{itemize}
  \item \file{NOHIGHMEM=y} сборка в режиме $\leq 1$\,Gb \ram
  \item \file{KERNEL\_GZIP=y} ядро сжимать алгоритмом \pack{gzip}\note{важно для
  загрузчиков на не-i386 системах}

  \item \emph{корневая файловая система в initrd/ramdisk}
  \begin{itemize}
  \item \file{BLK\_DEV\_INITRD=y} rootfs в \ram (initrd)
  \item \file{PROC\_FS=y} файловая подсистема \file{/proc}
  \item \file{SYSFS=y} файловая подсистема \file{/sys}
  \item \file{DEVTMPFS=y} файловая подсистема \file{/dev} (интерфейсы драйверов
  устройств)
  \item \file{DEVTMPFS\_MOUNT=y} автоматически монтировать \pack{devfs}
  \end{itemize}

  \item \emph{режим реального времени\note{повышенная или
  \emph{гарантированная} отзывчивость системы на внешние события}} \ref{linrt}
  \begin{itemize}
  \item \file{PREEMPT=y} \term{вытесняющая многозадачность} в режиме ядра
  \item \file{HZ\_1000=y} системный таймер 1\,KHz
  \end{itemize}

  \item \emph{исполняемые форматы файлов}
  \begin{itemize}
  \item \file{BINFMT\_ELF=y} бинарные файлы в формате \pack{ELF}
  \item \file{BINFMT\_SCRIPT=y} файлы скриптов с \verb|#!/bin/sh| в заголовке
  \item \file{COREDUMP=n} не писать \term{корки} при сбоях
  \end{itemize}

  \item \emph{поддержка консоли tty}
  \begin{itemize}
  \item \file{TTY=y} последовательные порты и командная консоль
  \item \file{UNIX98\_PTYS=n} псевдотерминалы UNIX98
  \item \file{LEGACY\_PTYS=n} псевдотерминалы UNIX/BSD
  \end{itemize}

  \item \emph{клавиатура}
  \begin{itemize}
  \item \file{INPUT\_KEYBOARD=y} ввод с аппаратной клавиатуры
  \end{itemize}

  \item \emph{мышь}
  \begin{itemize}
  \item \file{INPUT\_MOUSE=y}
  \item \file{INPUT\_MOUSEDEV=y}
  \item \file{INPUT\_MOUSEDEV\_PSAUX=n} не создавать \verb|/dev/psaux|
  \end{itemize}

  \item \emph{USB HID: устройства ввода без драйверов (клавиатура, мышь,
  джойстик, самодельные кнопки)\\включение поддержки USB на i386 не требуется}
  \begin{itemize}
  \item \file{HID=y} [H]uman [I]nterface [D]evice
  \item \file{HID\_GENERIC=y} универсальный драйвер USB HID Class
  \end{itemize}

  \item \emph{Графический режим \term{FrameBuffer}}
  \begin{itemize}
  \item \file{FB=y}
  \item \file{FRAMEBUFFER\_CONSOLE=y} командная консоль
  \item \file{LOGO=y} вывод пингвина при запуске
  \item \file{LOGO\_LINUX\_MONO=y} выводить только черно-белый вариант
  \item \file{LOGO\_LINUX\_VGA16=n}
  \item \file{LOGO\_LINUX\_CLUT224=n}
  \end{itemize}

  \item \emph{Отладка и \term{printk} лог ядра}
  \begin{itemize}
  \item \file{DEBUG\_KERNEL=y} включение отладочных функций ядра
  \item \file{EARLY\_PRINTK=y} вывод пусковой части ядра
  \item \file{PRINTK=y} вывод главного ситемного лога ядра \term{printk}
  \item \file{PRINTK\_TIME=y} выводить метки времени (для отладки времени
  запуска)
  \item \file{SCHED\_DEBUG=n} не отлаживать планировщик
  \item \file{DEBUG\_PREEMPT=n} не отлаживать вытесняющий режим
  \end{itemize}

  \end{itemize}
  \item \pack{arch} \emph{i386}

  \begin{itemize}

\item \file{X86\_GENERIC=y} универсальная оптимизация для всех i386-процессоров

\item \pack{UART/COM/RS232} \emph{последоваельные порты}
  \begin{itemize}
\item \file{SERIAL\_8250=y} UART 8250/16550
\item \file{SERIAL\_8250\_CONSOLE=y} командандная консоль на COM-портах
  \end{itemize}

\item \file{VGA\_CONSOLE=y} командандная консоль на VGA 80$\times$25

\item  \emph{FrameBuffer}
  \begin{itemize}
\item \file{FB\_VESA=y} универсальный видеодрайвер VESA 2.0+
  \end{itemize}

\item  \emph{клава}
  \begin{itemize}
\item \file{KEYBOARD\_ATKBD=y} клавиатура PC AT / PS2
  \end{itemize}

\item  \emph{мышь}
  \begin{itemize}
\item \file{MOUSE\_PS2=y} мышь PS/2
\item \file{MOUSE\_SERIAL=y} (старая) мышь на RS232
  \end{itemize}

\item \file{NVRAM=y} доступ к памяти CMOS

\item \emph{отладка}
  \begin{itemize}
\item \file{MAGIC\_SYSRQ=y} волшебная кнопка \keys{Alt+SysRq}
\item \file{X86\_VERBOSE\_BOOTUP=y} доп.сообщения при пуске ядра
  \end{itemize}

  \end{itemize}

  \item \pack{cpu} \emph{i386} \file{i486sx}

\begin{itemize}
  \item \file{M486=y}
  \item \file{MATH\_EMULATION=y} включить программную эмуляцию мат.сопроцессора
  (FPU) в ядре
\end{itemize}

  \item \pack{hw} \emph{qemu386} \file{qemu386}

\begin{itemize}
\item \file{MATH\_EMULATION=n} выключить эмуляцию FPU: \pack{QEMU} запускается
на процессорах Pentium и старше, которые всегда имеют аппаратный модуль
плавающей точки
\item \file{HZ\_1000=n}  в режиме эмуляции быстрый таймер не
имеет смысла,

\item \file{HZ\_100=y} переключаемся на 100\,Hz
\end{itemize}

\item \pack{app} \emph{micro}

\begin{itemize}
\item \file{FB=n} выключаем поддерку FrameBuffer,..
\item \file{INPUT\_MOUSE=n} мыши
\end{itemize}

\end{itemize}

\secrel{\pack{ulibc}: библиотека \pack{uClibc}} \label{azulibc}

\lstx{mk/ulibc.mk}{}{azlin/mk/ulibc.mk}{mk}

\begin{enumerate}
  \item подготовка к сборке с пустым \term{конфигом}
  \file{src/uClibc-x.x.x/.config}
  \item накатываем на пустой \file{.config} файлы-модификаторы, содержащие
  переопределения переменных конфигурации:
  \begin{itemize}
    \item \file{all} универсальные параметры \pack{ulibc} для всех платформ
    \item \file{arch} параметры, специфичные для архитектуры
    \item \file{cpu} параметры, адаптирующие \pack{ulibc} к конкретному
    процессору (набор команд и оптимизация)
    \item \file{app} параметры, в основном \emph{отключаемые} для конкретного
    \term{приложения} (отключение shared библиотек и неиспользуемых групп
    функций)
  \end{itemize}
  \item установка параметров кросс-компиляции и \emph{пути к хедерам ядра}
  \item запуск интерактивного меню конфигурирования, выйти с сохранением
  \item сборка \pack{ulibc}
  \item инсталляция в \pack{ROOT}
  \item инсталляция утилит для работы с shared библиотеками \emph{на целевой
  системе}
  \item инсталляция утилит для \emph{\file{BUILD}-системы}
  \item создание \file{/etc/ld.so.cache} (выполняется в пакете \pack{root})
\end{enumerate}
\bigskip

\begin{itemize}
\item
\begin{itemize}
\item \file{ARCH\_HAS\_MMU=y} \emph{всегда включено}
\item \file{ARCH\_USE\_MMU=y} \emph{всегда включено}
\item \file{UCLIBC\_HAS\_FPU=y} \emph{всегда включено}: используется эмулятор в
ядре
\item \file{UCLIBC\_HAS\_FLOATS=y} функции плавающей точки
\item \file{DO\_C99\_MATH=n} функции float math C99
\item \file{UCLIBC\_CTOR\_DTOR=y} конструктор/декструктор
\item \file{UCLIBC\_HAS\_LFS=y} большие файлы
\end{itemize}
\item \emph{разделяемые \term{shared} библиотеки}
\begin{itemize}
  \item \file{HAVE\_SHARED=y}
  \item \file{LDSO\_CACHE\_SUPPORT=y} \file{/etc/ld.co.conf}
  \item \file{LDSO\_PRELOAD\_ENV\_SUPPORT=n} переменная \file{LD\_PRELOAD}
  содержит список библиотек, загружаемых первыми
  \item \file{LDSO\_LD\_LIBRARY\_PATH=n} отключить
  переменную \file{LD\_LIBRARY\_PATH} со списком каталогов поиска shared
  библиотек
\end{itemize}
\item \emph{многопоточные \term{threads} программы }
\begin{itemize}
  \item \file{LINUXTHREADS\_OLD=y} \emph{старый} вариант потоков, новый вызывает
  segfault при использовании ключей gcc -lpthread и использовании shared ulibc
\end{itemize}
\item \emph{параметры установки}
\begin{itemize}
\item \file{DOSTRIP=y}
\item \file{RUNTIME\_PREFIX=""}
\item \file{DEVEL\_PREFIX=""}
\end{itemize}
\item \emph{опции необходимые \pack{busybox}}
\begin{itemize}
\item \file{UCLIBC\_HAS\_CTYPE\_TABLES=y}
\item \file{UCLIBC\_HAS\_NETWORK\_SUPPORT=y}
\item \file{UCLIBC\_HAS\_FNMATCH=y}
\item \file{UCLIBC\_HAS\_GNU\_GETOPT=y}
\item \file{UCLIBC\_HAS\_REGEX=y}
\item \file{UCLIBC\_SUSV3\_LEGACY=y}
\end{itemize}
\item
\begin{itemize}
\end{itemize}
\end{itemize}

\lstx{ulibc/all}{}{azlin/ulibc/all}{mk}

\lstx{ulibc/arch/i386}{}{azlin/ulibc/arch/i386}{mk}

\lstx{ulibc/cpu/i486sx}{}{azlin/ulibc/cpu/i486sx}{mk}

\secrel{\pack{gcc}: пересборка полного \pack{gcc}} \label{azgcc}

После сборки \pack{ulibc}\ необходимо еще раз пересобрать \pack{gcc}\ с полными
настройками.

\secrel{\pack{busybox}: набор утилит \pack{busybox}} \label{azbb}

\lstx{mk/busybox.mk}{}{azlin/mk/busybox.mk}{mk}

\begin{enumerate}
  \item подготовка к сборке с пустым \term{конфигом}
  \item интерактивное меню конфигурирования \emph{с сохранением конфига в
  \file{app/\$\{APP\}.bb}}
  \item сборка и инсталляция в \file{ROOT}
\end{enumerate}

\bigskip
Особенность \pack{busybox}\ --- скрипты конфигурации не умеют отрабатывать
переписывание переменных конфигурации, поэтому приходиться держать в
\file{app/*.bb} настройки для каждого приложения полностью. Если вы создаете
свое приложение, скопируйте \file{app/micro.bb} в качестве базовой версии вашего
\file{app/userapp.bb}.

\secrel{\pack{libs}: сборка библиотек \file{\$\{LIBS\}}} \label{azlibs}

\secrel{\pack{apps}: сборка прикладных пакетов \file{\$\{APPS\}}}
\label{azapps}

\secrel{\pack{user}: сборка пользовательского кода} \label{azuser}

\secrel{\pack{root}: формирование корневой файловой системы} \label{azroot}

\lstx{mk/root.mk}{}{azlin/mk/root.mk}{mk}

\begin{enumerate}
  \item пересоздание \file{/etc/}
  \item генерация \term{кеша динамических библиотек} \file{/etc/ld.so.cache}
  \item \file{/sbin/init} $\rightarrow$ \file{/init}
  \item \file{/share/}
  \item создание \pack{initrd} используя фильтрацию файлов \term{регулярным
  выражением} в переменной \file{ROOTREX}
\end{enumerate}

\lst{/etc/inittab}{}{azlin/etc/inittab}

\lstx{/etc/init.d/rcS}{}{azlin/etc/init.d/rcS}{rc}

\begin{enumerate}
  \item создание системных каталогов
  \item запуск \term{демона} \pack{mdev}, обслуживающего \file{devfs}:
  создание/удаление устройств в \file{/dev}, автомонтирование, загрузка
  прошивок,..
  \item вывод \file{README}
\end{enumerate}

\lstx{/etc/init.d/rcD}{}{azlin/etc/init.d/rcD}{rc}

\secrel{\pack{boot}: сборка загрузчика
\pack{syslinux}/\pack{grub}/\pack{uboot}} \label{azboot}

\lstx{mk/boot.mk}{}{azlin/mk/boot.mk}{mk}

\secrel{\pack{syslinux}}

\secrel{\pack{grub}}

\secrel{\pack{uboot}}

\secrel{\pack{emu}: запуск собранной системы в эмуляторе} \label{azemu}

Для отладки кода, не связанного жестко с железом, для которого
допускается выполнение в эмуляторе, используется \pack{QEMU}.

\lstx{mk/emu.mk}{}{azlin/mk/emu.mk}{mk}

\lstx{hw/qemu386.mk}{}{azlin/hw/qemu386.mk}{mk}

Переменная \verb|QEMU_CFG| задает параметры запуска \pack{QEMU}:

\begin{tabular}{l l}
\file{-m} & объем \ram\ на эмулируемой системе \\
\file{-net none} & отключить сеть и iPXE boot \\
\hline
\file{-kernel} & прямая загрузка ядра \linux\ из файла \\
\file{-initrd} & образ корневой файловой системы (\file{initrd}) \\
\file{-append} & параметры ядра: \\
\file{vga=ask} & запрос списка видеорежимов при загрузке и выбор режима \\
\file{vga=none} & std. VGA text 80$\times$25, FrameBuffer отключен \\
\file{vga=0x315} & VESA 800$\times$600$\times$24bit \\
\file{vga=0x317} & VESA 1024$\times$768$\times$16bit \\
\end{tabular}

\begin{verbatim}
  Mode 0x0301: 640x480 (+640), 8 bits
  Mode 0x0303: 800x600 (+800), 8 bits
  Mode 0x0305: 1024x768 (+1024), 8 bits
  Mode 0x0311: 640x480 (+1280), 16 bits
  Mode 0x0312: 640x480 (+2560), 24 bits
  Mode 0x0314: 800x600 (+1600), 16 bits
  Mode 0x0315: 800x600 (+3200), 24 bits
  Mode 0x0317: 1024x768 (+2048), 16 bits
  Mode 0x0318: 1024x768 (+4096), 24 bits
\end{verbatim}

\secup

\secrel{\pack{netboot}: Сетевая загрузка} \label{aznetboot}

\secrel{Прошивка на устройство} \label{azfirmware}

\secrel{RT-патч}

\secrel{SDK: расширения для on-board разработки}\secdown

Иногда на целевой системе требуется набор средств программирования, для
выполнения

\begin{itemize}
  \item
сложных скриптов (Python \ref{azpython}),
  \item
математических вычислений\note{в т.ч. и символьных (аналитических, не
численных)} (GCL \ref{azgcl}/Maxima \ref{azmaxima}),
  \item
или компиляции неизвестных заранее исходников:
\begin{itemize}
 \item обновления или отладка прошивок для периферийных контроллеров
 \item пересборки программ в хост-системе
 \item отладки программ, активно работающих со специфичным железом
\end{itemize}
\end{itemize}

Для этого в состав az\linux\ включен набор расширений SDK\note{[S]oftware
[D]evelopment [K]it}.

\secrel{\pack{canadian}: сборка binutils канадским крестом}

\termdef{Канадский крест}{канадский крест}\ --- метод кросс-компиляции
\prog{binutils}/\prog{gcc}, когда явно указываются три \term{триплета}:

\begin{description}
  \item[--build] платформа, на которой выполняется сборка, т.е. ваш
  билд-сервер: x86\_64 или i686
  \item[--host] платформа, на которой будет выполняться собранный
  кросс-компилятор, т.е. TARGET нашей встраиваемой системы: i386-linux-uclibc,
  arm-linux-gnueabihf или что-то подобное
  \item[--target] платформа или микропроцессор, для которого кросс-компилятор
  будет генерировать код, например \cm{3}.
\end{description}

\lstx{mk/sdk/canadian.mk}{}{azlin/mk/sdk/canadian.mk}{mk}

\secrel{\pack{binhost}: binutils для хост-процессора}

Ассемблер и линкер для компиляции и (пере)сборки бинарников для процессора
хост-системы.

\secrel{\pack{binavr8}: binutils для Atmel ATmega (AVR8)}

Компиляция и прошивка периферийных контроллеров на популярных микропроцессорах
Atmel ATmega (AVR8).

\secrel{\pack{bincmx}: binutils для ARM \cmx}

Компиляция и прошивка периферийных контроллеров на микропроцессорах
перспективной линейки \cmx.

\secrel{\pack{fpc}: FreePascal}

\lstx{mk/sdk/pascal.mk}{}{azlin/mk/sdk/pascal.mk}{mk}

\secrel{\pack{python}: интерпретатор Python}\label{azpython}

\secrel{\pack{gcl}: GNU Common Lisp}\label{azgcl}

\secrel{\pack{maxima}: система символьной математики
\prog{Maxima}}\label{azmaxima}

\secup

\secup
