\chapter{azLinux}

Чтобы разобраться как можно собрать встраивамый \linux, в этом разделе описан
набор \make-файлов и файлов конфигурации для сборки минимального \emlinux.
Это обрезанный форк проекта \href{https://github.com/ponyatov/cross}{Cross
Linux}, подробнее описанного в разделе \ref{cross}. Ограничено количество
поддерживаемого железа, упрощены конфигурационные файлы, минимизировано
количество библиотек и программных пакетов.

\bigskip

Изначально идея создания этой системы появилась из желания заменить тухлую
связку x86/DOS/Tur\-bo\-Pas\-cal на что-то

\begin{itemize}
  \item \emph{более переносимое}: на
 энергоэффективное ARM/MIPS-железо, в т.ч. (типа)отечественного производства,
\item \emph{стабильное}: с полноценной многозадачностью,
защитой памяти и данных, и
\item \emph{позволяющее использовать максимум возможностей аппаратуры}: большая
\ram, ECC, gcc-оп\-ти\-ми\-зи\-ро\-ван\-ный 32/64-битный код, USB, CAN, Ethernet,
WiFi, разнообразные носители данных, аппаратный watchdog.
 
\item Также большой интерес представляют \emph{десятки готовые библиотек} сжатия
и кодирования данных, численных методов, ЦОС, и обработки изображений, а также

\item множество \emph{готовых программ, доступных в исходных кодах}\note{для
использования как есть, изучения принципов работы и модификации под
собственные нужды}\ для выполнения различных полезных функций: сетевые серверы,
символьная математика, обработка данных,\ldots

\item Еще одна ключевая фича\ --- \emph{способность}\ \linux\ полностью
\emph{загружаться в \ram\ с \textbf{любых} носителей, в т.ч. заблокированных на
запись}. Это важно для случаев, когда возможны внезапные выключения питания:
вся система работает в \ram-диске, а корректность записи данных на изменяемые
носители можно гибко контролировать программно. При запуске после аварийного
выключения никаких проверок файловых систем не требуется, ОС стартует сразу, а
проверку/починку разделов данных возможно выполнять в фоновом режиме.

\item \emph{Время запуска системы}\ --- на x86 удалось экспериментально получить
время запуска \emph{0.2\,сек от загрузки ядра до начала выполнения
пользователького кода}.
Используя модульное ядро, возможно выполнить критический к времени запуска
пользовательский код до инициализации USB, сети, внешних носителей данных и
тяжелых сервисов.

\end{itemize}

\paragraph{Почему не BuildRoot}

Эта система сборки создавалась как \emph{максимально облегченный пакет
для решения узких задач}, и для освоения технологии кросс-компиляции.
Предполагается что функциональное наполнение не будет развиваться шире набора:

\begin{itemize}
  \item ядро (реального времени)
  \item libc
  \item урезанная командная оболочка (busybox)
  \item несколько прикладных библиотек поддержки (сжатие, кодирование, базовая
  графика)
  \item пользовательский узкоспециализированный код на Си/\cpp
\end{itemize}

Расширять функционал, добавляя libQt, X Window, Apache, MySQL,\ldots, Gnome/KDE
и т.д. не планируется в принципе\ --- \emph{это система для решения узких
прикладных задач}\ на аппаратуре с минимальными ресурсами\note{особенно
интересны процессорные модули в DIMM форм-факторе, только CPU, RAM,
NAND и GPIO гребенка}. \emph{Интерактивная работа}\ с пользователем также
\emph{не предполагается}, доступна только командная консоль\note{ее можно
считать сервисным режимом}, и очень ограниченные графические и мультимедийные
возможности. Если ваши хотелки выходят за этот функционал, рекомендую сразу
уходить на использование ширко известной системы кросс-сборки \linux-систем под
названием \file{BuildRoot}\ref{buildroot}.

\section{Требования к системе сборки (\file{BUILD}-хост\'{у})}

Требования жесткие\ --- 2х-ядерный процессор, 2+\,Гб \ram, для 4+\, Гб \ram\
нужен 64х-битный дистрибутив \linux\ (рекомедую Debian), и естественно никаких
виртуалок.

Возможна установка системы на флешку, в этом случае требования к \ram\ еще более
ужесточаются\ --- потребуется каталоги с временными файлами смонтировать как
\file{tmpfs}:

\lst{добавить в \file{/etc/fstab}}{}{azlin/ramfstab.txt}

Можно попытаться сделать \term{билд-сервер}\ и на худшем железе, но будьте
готовы к тормозам или внезапному окончанию памяти\ --- ресурсоемка сборка
тяжелых библиотек типа \pack{libQt}\ или крупных пакетов типа \pack{gcc}.

Вы можете попробовать поставить \linux\ на виртуалку, на флешку, и на жесткий
диск (если найдете место) и оценить возможности этих вариантов на сборке пакета
\pack{gcc}. При сборке с флешки на ноутбуке с 2\,Гб \ram\ мне для сборки
\pack{gcc}\ пришлось временно размонтировать \file{azlin/src}, сделать
\file{./mk.rc \&\& make gcc ramclean}, а потом примонтировать \file{tmpfs}\
опять на \file{src}.

Сборка под MinGW/Cygwin совершенно неживая. Если совсем никак без винды\ ---
используйте виртуалки, и будьте готовы ждать.

\section{Использование пакета сборки az\linux}

\subsection{Загрузка}

При необходимости вносить правки\note{что естественно\ --- вам потребуется
добавлять свои пакеты и поддержку железа}\ работайте с вашим
собственным форком на GitHub.

Получите клон пакета из репозитория:

\begin{verbatim}
cd ~ ; git clone --depth=1 -o gh https://github.com/ponyatov/azlin az
\end{verbatim}

При необходимости обновитесь:

\begin{verbatim}
cd ~/az ; git pull
\end{verbatim}

Остальные действия выполняются с помощью команды \prog{make}. Обратите особое
внимание на то, что \file{Makefile}\ собирается скриптом \prog{mk.rc}\ из частей
в каталоге \file{mk/}, поэтому \emph{если вы что-то меняете в скриптах, не
забудьте сначала запустить \prog{./mk.rc}}.

\lst{mk.rc}{}{azlin/mk.rc}

\subsection{Пакеты}

Прежде чем продолжить, введем понятие \term{пакет}. В az\linux\ \term{пакетом}\
называется одна или несколько частей скриптов сборки, обозначаемых именем. В
чем-то это похоже на бинарные пакеты обычных дистрибутивов \linux\ --- чтобы
добавить в систему какой-то функционал, мы устанавливаем \term{бинарный пакет}.
Но есть и отличие: пакет дистрибутива это реальный архивный файл, содержащий в
себе файлы программ, данных; в az\linux\ пакет\ --- виртуальная штука с именем.

Просматривая файлы в каталоге \file{mk/}, легко найти имена пакетов по шаблону:

\begin{verbatim}
.PHONY: somename
somename: [deps]
    [cmd]
    ...
\end{verbatim}

Если вы запустите команду:

\begin{verbatim}
cd ~/az ; ./mk.rc && make somename
\end{verbatim}

запустится \term{сборка пакета}\ \pack{somename}.

Но не нужно забывать, что кроме этой секции в \file{.mk}, существуют зависимости
между файлами, при работе команд сборки динамически создаются и изменяются
файлы, иногда что-то скачивается из \internet а\ --- все эти процессы тоже
входят в пакет.

\section{APP: Приложение}

\term{Приложение}\ --- короткое кодовое название вашего варианта сборки системы
в целом.

Приложение задается в файле \file{mk/head.mk}\ через
переменную \file{APP}, доступные значения:

\begin{enumerate}
  \item \prog{micro}: минимальная версия системы, только командная консоль
  \item \prog{clock}: простые \linux-powered электронные часы
\end{enumerate}

В \file{app/\$\{APP\}.mk}\ в переменных задаются:

\begin{itemize}
  \item \file{LIBS}: набор используемых библиотек
  \item \file{PACKS}: набор используемых программных пакетов \ref{azpacks}
\end{itemize} 

\section{HW: Поддерживаемое железо}

Конфигурация целевого железа задается в файле \file{mk/head.mk}\ через
переменную \file{HW}, доступные значения приведены в таблице:

\noindent
\begin{tabular}{|l| l l|l l l l l|l|}
\hline
HW & CPU & ARCH & RAM & HDD/NAND & SD & USB & WiFi & GPIO \\
\hline
qemu386 & i486sx & i386 & 32M+ & \uncheckbox\ IDE/SATA & & \uncheckbox &&\\
eeepc701 & CeleronM & i386 & 512M+ & \uncheckbox\ SSD 4G & \uncheckbox\
SD & \checkbox & \uncheckbox\ Atheros AR2425 &\\
\hline
qemuARM & & arm & 32M+ &&&&&\\
cubie1 & AllWinnerA10 & armhf & 1G && \uncheckbox\ $\mu$SD & \checkbox &&\\
rpi & BCM2835 & armel & 512M && \uncheckbox\ SD&\checkbox&&\\
\hline
qemuMIPS & &mips& 32M+ & & & & &\\
mr3020 & AR7240 &mips& 32M & 4M & & \checkbox & \uncheckbox\ Atheros AR9331 &\\
vocore & RT5350 &mips& 32M & 8M & & \uncheckbox
& \uncheckbox\ SoC &\\
bswift & AR9331 &mips& 64M & 16M
NOR & & \uncheckbox\ host & & 20+ \\
\hline
\end{tabular}

\lst{mk/head.mk}{}{azlin/mk/head.mk}

\subsection{i386}

Персоналки с архитектурой \file{i386}\ --- самое сложное семейство с точки
зрения поддержки. Комбинации процессоров, материнских плат и плат расширений
дают сотни вариантов конфигураций, в т.ч. десятки моделей компьютеров в формате
PC/104 и промышленных панелей. Особенно доставляет тот факт, что 95\% периферии
имеет закрытые бинарные драйвера только для \win, поэтому будьте аккуратны с
выбором железа.

\subsubsection{qemu386: эмулятор QEMU}

\lst{hw/qemu386.mk}{}{azlin/hw/qemu386.mk}

\subsubsection{eeepc701: ASUS Eee PC 701}

\lst{hw/eeepc701.mk}{}{azlin/hw/eeepc701.mk}

\subsection{ARM}

\subsubsection{qemuARM: эмулятор QEMU}
\lst{hw/qemuARM.mk}{}{azlin/hw/qemuARM.mk}
\subsubsection{cubie1: Cubie Board v.1}
\subsubsection{rpi: Raspberry Pi model B}
\subsection{MIPS}
\subsubsection{qemuMIPS: эмулятор QEMU}
\lst{hw/qemuMIPS.mk}{}{azlin/hw/qemuMIPS.mk}
\subsubsection{mr3020: роутер MR3020}
\href{http://wiki.openwrt.org/ru/toh/tp-link/tl-mr3020}{mr3020}
\subsubsection{vocore: VoCore} 
\href{http://vocore.io/}{vocore}
\subsubsection{bswift: BlackSwift}
\href{http://habrahabr.ru/post/242731/}{bswift} 

\section{CPU: Конфигурации процессоров}

Настройки на процессор задаются в файле \file{cpu/\$\{CPU\}.mk}.

\subsection{i386}

\lst{cpu/i486sx.mk}{}{azlin/cpu/i486sx.mk}

\lst{cpu/CeleronM.mk}{}{azlin/cpu/CeleronM.mk}

\subsection{ARM}
\subsection{MIPS}

\lst{cpu/AR7240.mk}{}{azlin/cpu/AR7240.mk}

\lst{cpu/RT5350.mk}{}{azlin/cpu/RT5350.mk}

\section{Пакеты}\label{azpacks}

